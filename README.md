# Operational-systems
Лабораторные работы по курсу "Операционные системы", МАИ ПМИ 2 курс 3 семестр

## Лабораторная работа №2, вариант 15
Задание: составить и отладить программу на языке Си, осуществляющую работу с
процессами и взаимодействие между ними. В результате работы программы основной
процесс должен создать для решения задачи один или несколько дочерних процессов.
Взаимодействие между процессами осуществляется через системные сигналы/события
и/или каналы (pipe)

Вариант: родительский процесс создает дочерний процесс. Первой строкой пользователь в консоль родительского процесса вводит имя файла, которое будет использовано для открытия File с таким именем на запись. Перенаправление стандартных
потоков ввода-вывода показано на картинке выше. Родительский и дочерний процесс
должны быть представлены разными программами. Родительский процесс принимает
от пользователя строки произвольной длины и пересылает их в pipe1. Процесс child
проверяет строки на валидность правилу. Если строка соответствует правилу, то она
выводится в стандартный поток вывода дочернего процесса, иначе в pipe2 выводится
информация об ошибке. Родительский процесс полученные от child ошибки выводит в
стандартный поток вывода. Правило проверки: строка должна начинаться с заглавной
буквы.

## Лабораторная работа №3, вариант 19
Задание: составить программу на языке Си, обрабатывающую данные в многопоточном режиме. При обработки использовать стандартные средства создания потоков операционной системы (Windows/Unix). Ограничение потоков должно быть задано
ключом запуска вашей программы. Так же необходимо уметь продемонстрировать количество потоков, используемое вашей программой с помощью стандартных средств
операционной системы. В отчете привести исследование зависимости ускорения и эффективности алгоритма от входящих данных и количества потоков. Получившиеся результаты необходимо объяснить.

Вариант: необходимо реализовать проверку числа на простоту при помощи алгоритма "решето Эратосфена".

## Лабораторная работа №4, вариант 15
Задание: составить и отладить программу на языке Си, осуществляющую работу
с процессами и взаимодействие между ними в одной из двух операционных систем. В
результате работы программа (основной процесс) должен создать для решение задачи
один или несколько дочерних процессов. Взаимодействие между процессами осуществляется через системные сигналы/события и/или через отображаемые файлы (memory mapped files). Необходимо обрабатывать системные ошибки, которые могут возникнуть
в результате работы.

Вариант: см. лабораторную работу №2

## Лабораторная работа №5, вариант 3
Задание: требуется создать динамические библиотеки, которые реализуют определённый функционал. Далее использовать эти библиотеки 2 способами:
1. Во время компиляции (на этапе линковки).
2. Во время исполнения программы. 

Библиотеки загружаются в память с помощью
интерфейса ОС для работы с динамическими библиотеками.
В конечном итоге в лабораторной работе необходимо получить следующие части:
1. Динамические библиотеки, реализующие контракты, заданые вариантом.
2. Тестовая программа №1, которая использует одну из библиотек, используя знания,
полученные на этапе компиляции.
3. Тестовая программа №2, которая загружает библиотеки, используя только их местоположение и контракты.

Пользовательский ввод для обоих программ должен быть организован следующим образом:
1. Если пользователь вводит команду «0», то программа переключает одну реализацию контрактов на другую (необходимо только для программы №2). Можно
реализовать лабораторную работу без данной функции, но максимальная оценка
в этом случае будет «хорошо»;
2. «1 arg1 arg2 . . . argN», где после «1» идут аргументы для первой функции, предусмотренной контрактами. После ввода команды происходит вызов первой функции, и на экране появляется результат её выполнения;
3. «2 arg1 arg2 . . . argM», где после «2» идут аргументы для второй функции, предусмотренной контрактами. После ввода команды происходит вызов второй функции, и на экране появляется результат её выполнения.

Вариант: расчёт интеграла функции sin x на отрезке [A, B] с шагом e методом
прямоугольников и методом трапеций; подсчёт наибольшего общего делителя двух натуральных чисел (с помощью алгоритма Евклида и с помощью наивного алгоритм

## Лабораторная работа №6, вариант 29
Задание: реализовать распределённую систему по асинхронной обработке запросов.
В данной системе должно существовать два вида узлов: "управдяющий"и "вычислительный". Необходимо объединить данные узлы в соответствии с той топологией, которая определена вариантом. Связь между узлами необходимо осуществить при помощи
технологии очередей сообщений. Также в данной системе необходимо предусмотреть
проверку доступности узлов в соответствии с вариантом. При убийстве («kill -9») любого вычислительного узла система должна пытаться максимально сохранять свою работоспособность, а именно все дочерние узлы убитого узла могут стать недоступными,
но родительские узлы должны сохранить свою работоспособность.
Управляющий узел отвечает за ввод команд от пользователя и отправку этих команд
на вычислительные узлы. Список основных поддерживаемых команд:
1. create id — создание нового вычислительного узла
2. exec id params — исполнение команды на вычислительном узле
3. heartbeat time — проверка доступности узлов

Вариант: бинарное дерево поиска, сумма чисел, heartbeat.

## Курсовая работа, вариант 19
Задание: необходимо релаизовать два алгоритма аллокации памяти и сравнить их.
Каждый аллокатор памяти должен иметь функции аналогичные стандартным функциям free и malloc. Перед работой каждый аллокатор инициализируется свободными
страницами памяти, выделенными стандартными средствами ядра. В отчёте необходимо отобразить следующее:
1. Подробное описание каждого из исследуемых алгоритмов.
2. Процесс тестирования.
3. Обоснование подхода тестирования.
4. Результат тестирования.
5. Заключение по проведённой работе.

Каждый аллокатор должен обладать следующим интерфейсом:
1. Allocator* createMemoryAllocator(void* realMemory, size_t memory_size) - создание аллокатор памяти размера memory_size.
2. void* alloc(Allocator* allocator, size_t block_size) - выделение памяти при помощи
аллокатора размера block_size.
3. void* free(Allocator* allocator, void* block) - возвращает выделенную память аллокатору.

Вариант 19: сравнить алгоритм аллокации на списках свободных блоков и на блоках по 2 в степени n.

